<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitmain HD5 - Container + Dry Cooler Empil√©s</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 107, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            min-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 100;
        }

        .ui-panel h2 {
            color: #FF6B00;
            font-size: 18px;
            margin-bottom: 5px;
        }

        .ui-panel .subtitle {
            color: #00A651;
            font-size: 12px;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group h3 {
            color: #FF6B00;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .spec-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 11px;
        }

        .spec-label {
            color: #888;
        }

        .spec-value {
            color: #fff;
            font-weight: 600;
        }

        button {
            width: 100%;
            padding: 10px;
            background: #FF6B00;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 6px;
        }

        button:hover {
            background: #E55A00;
        }

        button.secondary {
            background: rgba(255, 255, 255, 0.1);
        }

        .highlight {
            background: rgba(0, 166, 81, 0.1);
            border: 1px solid #00A651;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 11px;
            color: #00A651;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="ui-panel">
        <h2>‚ö° Bitmain ANTSPACE HD5</h2>
        <div class="subtitle">Container + Dry Cooler Empil√©s</div>
        
        <div class="control-group">
            <h3>Actions</h3>
            <button onclick="resetCamera()">üéØ R√©initialiser</button>
            <button onclick="toggleGrid()" class="secondary">üìê Grille</button>
            <button onclick="toggleWireframe()" class="secondary">üî≤ Wireframe</button>
        </div>

        <div class="control-group">
            <h3>Structure Empil√©e</h3>
            <div class="spec-item">
                <span class="spec-label">üì¶ Container Minage</span>
                <span class="spec-value">En bas</span>
            </div>
            <div class="spec-item">
                <span class="spec-label">‚ùÑÔ∏è Dry Cooler</span>
                <span class="spec-value">Au-dessus</span>
            </div>
            <div class="spec-item">
                <span class="spec-label">üìè M√™me taille</span>
                <span class="spec-value">12.196m √ó 2.438m</span>
            </div>
            <div class="spec-item">
                <span class="spec-label">üî∫ Radiateur V</span>
                <span class="spec-value">Sur dry cooler</span>
            </div>
        </div>

        <div class="control-group">
            <h3>Dimensions</h3>
            <div class="spec-item">
                <span class="spec-label">Longueur</span>
                <span class="spec-value">12.196 m</span>
            </div>
            <div class="spec-item">
                <span class="spec-label">Largeur</span>
                <span class="spec-value">2.438 m</span>
            </div>
            <div class="spec-item">
                <span class="spec-label">Hauteur container</span>
                <span class="spec-value">2.896 m</span>
            </div>
            <div class="spec-item">
                <span class="spec-label">Hauteur dry cooler</span>
                <span class="spec-value">~2.896 m</span>
            </div>
            <div class="spec-item">
                <span class="spec-label">Hauteur totale</span>
                <span class="spec-value">~6.0 m</span>
            </div>
        </div>

        <div class="highlight">
            ‚úÖ Container de minage en bas<br>
            ‚úÖ Dry cooler (m√™me taille) au-dessus<br>
            ‚úÖ Radiateur en V sur le dry cooler<br>
            ‚úÖ Structure empil√©e verticalement
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Couleurs r√©alistes
        const COLORS = {
            // Container minage (bas)
            containerBody: 0xE8E8E8,      // Blanc/gris clair
            containerFrame: 0xC0C0C0,     // Gris moyen
            
            // Dry cooler (haut)
            dryCoolerBody: 0xD0D0D0,     // Gris clair
            radiatorV: 0x909090,          // Gris pour radiateur V
            
            // Dalle
            concrete: 0xB0B0B0,           // Gris b√©ton
            
            // Ventilation
            ventGrilles: 0x404040,        // Gris fonc√©
            
            // Logos
            bitmainOrange: 0xFF6B00,
            hearstGreen: 0x00A651,
            
            // Environnement
            ground: 0x8B7355
        };

        let scene, camera, renderer, gridHelper;
        let containerGroup;
        let wireframeMode = false;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 50, 150);

            camera = new THREE.PerspectiveCamera(
                50,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(30, 20, 30);
            camera.lookAt(0, 3, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            setupControls();
            setupLights();
            createGround();
            createGrid();
            createStackedSystem();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let rotation = { x: 0.3, y: 0.5 };
            let zoom = 35;

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                rotation.y += deltaX * 0.005;
                rotation.x += deltaY * 0.005;
                rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));
                updateCameraPosition();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                zoom += e.deltaY * 0.02;
                zoom = Math.max(15, Math.min(80, zoom));
                updateCameraPosition();
            });

            function updateCameraPosition() {
                camera.position.x = zoom * Math.sin(rotation.y) * Math.cos(rotation.x);
                camera.position.y = zoom * Math.sin(rotation.x);
                camera.position.z = zoom * Math.cos(rotation.y) * Math.cos(rotation.x);
                camera.lookAt(0, 3, 0);
            }
        }

        function setupLights() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(15, 25, 15);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            scene.add(directionalLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-10, 15, -10);
            scene.add(fillLight);
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: COLORS.ground,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createGrid() {
            gridHelper = new THREE.GridHelper(100, 100, 0xFF6B00, 0x333333);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
        }

        function createStackedSystem() {
            containerGroup = new THREE.Group();

            // 1. DALLE B√âTON
            const dalleGeometry = new THREE.BoxGeometry(13.0, 0.4, 3.0);
            const dalleMaterial = new THREE.MeshStandardMaterial({
                color: COLORS.concrete,
                roughness: 0.9
            });
            const dalle = new THREE.Mesh(dalleGeometry, dalleMaterial);
            dalle.position.y = 0.2;
            dalle.castShadow = true;
            dalle.receiveShadow = true;
            containerGroup.add(dalle);

            // 2. CONTAINER DE MINAGE (EN BAS)
            const containerHeight = 2.896;
            const containerGeometry = new THREE.BoxGeometry(12.196, containerHeight, 2.438);
            const containerMaterial = new THREE.MeshStandardMaterial({
                color: COLORS.containerBody,
                roughness: 0.4,
                metalness: 0.3
            });
            const miningContainer = new THREE.Mesh(containerGeometry, containerMaterial);
            miningContainer.position.y = 0.4 + containerHeight / 2; // Sur la dalle
            miningContainer.castShadow = true;
            containerGroup.add(miningContainer);

            // D√©tails container minage
            createMiningContainerDetails(miningContainer);

            // 3. DRY COOLER (AU-DESSUS - M√äME TAILLE)
            const dryCoolerHeight = 2.896; // M√™me hauteur que le container
            const dryCoolerGeometry = new THREE.BoxGeometry(12.196, dryCoolerHeight, 2.438);
            const dryCoolerMaterial = new THREE.MeshStandardMaterial({
                color: COLORS.dryCoolerBody,
                roughness: 0.5,
                metalness: 0.4
            });
            const dryCooler = new THREE.Mesh(dryCoolerGeometry, dryCoolerMaterial);
            // Positionn√© juste au-dessus du container
            dryCooler.position.y = 0.4 + containerHeight + dryCoolerHeight / 2;
            dryCooler.castShadow = true;
            containerGroup.add(dryCooler);

            // 4. RADIATEUR EN V (SUR LE DRY COOLER)
            createVRadiator(dryCooler);

            // 5. D√âTAILS DRY COOLER
            createDryCoolerDetails(dryCooler);

            // 6. TUYAUTERIE DE CONNEXION
            createConnectionPipes(miningContainer, dryCooler);

            // 7. LOGOS
            createLogos(miningContainer);

            scene.add(containerGroup);
        }

        function createMiningContainerDetails(container) {
            // Panneaux de ventilation avant
            const panelMaterial = new THREE.MeshStandardMaterial({
                color: COLORS.containerBody,
                roughness: 0.5
            });

            for (let i = -2; i <= 2; i++) {
                const panelGeometry = new THREE.BoxGeometry(1.8, 2.6, 0.05);
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                panel.position.set(-6.12, 0, i * 0.5);
                container.add(panel);
            }

            // Grilles de ventilation
            const grilleMaterial = new THREE.MeshStandardMaterial({
                color: COLORS.ventGrilles,
                roughness: 0.6
            });

            for (let i = -2; i <= 2; i++) {
                for (let j = -10; j <= 10; j++) {
                    const grilleGeometry = new THREE.BoxGeometry(1.6, 0.02, 0.08);
                    const grille = new THREE.Mesh(grilleGeometry, grilleMaterial);
                    grille.position.set(-6.14, j * 0.12, i * 0.5);
                    container.add(grille);
                }
            }
        }

        function createVRadiator(dryCooler) {
            // Radiateur en forme de V sur le dessus du dry cooler
            const radiatorMaterial = new THREE.MeshStandardMaterial({
                color: COLORS.radiatorV,
                roughness: 0.4,
                metalness: 0.6
            });

            // Cr√©er un radiateur en V (deux plans inclin√©s)
            const vAngle = Math.PI / 6; // 30 degr√©s
            const radiatorWidth = 11.0;
            const radiatorHeight = 2.0;
            const radiatorDepth = 0.3;

            // Plan gauche du V
            const leftPlaneGeometry = new THREE.BoxGeometry(radiatorWidth, radiatorHeight, radiatorDepth);
            const leftPlane = new THREE.Mesh(leftPlaneGeometry, radiatorMaterial);
            leftPlane.rotation.z = vAngle;
            leftPlane.position.set(0, 1.5, 0);
            leftPlane.position.x = -radiatorWidth * 0.2;
            dryCooler.add(leftPlane);

            // Plan droit du V
            const rightPlane = new THREE.Mesh(leftPlaneGeometry, radiatorMaterial);
            rightPlane.rotation.z = -vAngle;
            rightPlane.position.set(0, 1.5, 0);
            rightPlane.position.x = radiatorWidth * 0.2;
            dryCooler.add(rightPlane);

            // Base du radiateur V
            const baseGeometry = new THREE.BoxGeometry(radiatorWidth, 0.2, radiatorDepth);
            const base = new THREE.Mesh(baseGeometry, radiatorMaterial);
            base.position.set(0, 0.5, 0);
            dryCooler.add(base);
        }

        function createDryCoolerDetails(dryCooler) {
            // Ventilateurs sur les c√¥t√©s du dry cooler
            const fanGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32);
            const fanMaterial = new THREE.MeshStandardMaterial({
                color: 0x606060,
                roughness: 0.5
            });

            // Ventilateurs lat√©raux
            for (let i = -4; i <= 4; i += 2) {
                const fan1 = new THREE.Mesh(fanGeometry, fanMaterial);
                fan1.rotation.x = Math.PI / 2;
                fan1.position.set(i, 0, -1.3);
                dryCooler.add(fan1);

                const fan2 = new THREE.Mesh(fanGeometry, fanMaterial);
                fan2.rotation.x = Math.PI / 2;
                fan2.position.set(i, 0, 1.3);
                dryCooler.add(fan2);
            }

            // Grilles de ventilation sur les c√¥t√©s
            const grilleMaterial = new THREE.MeshStandardMaterial({
                color: COLORS.ventGrilles,
                roughness: 0.6
            });

            for (let i = -5; i <= 5; i++) {
                const grilleGeometry = new THREE.BoxGeometry(0.05, 2.5, 0.1);
                const grille = new THREE.Mesh(grilleGeometry, grilleMaterial);
                grille.position.set(i * 1.0, 0, -1.25);
                dryCooler.add(grille);

                const grille2 = new THREE.Mesh(grilleGeometry, grilleMaterial);
                grille2.position.set(i * 1.0, 0, 1.25);
                dryCooler.add(grille2);
            }
        }

        function createConnectionPipes(miningContainer, dryCooler) {
            // Tuyauterie de connexion entre les deux containers
            const pipeGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3.0, 16);
            const pipeMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A90E2,
                roughness: 0.3,
                metalness: 0.7
            });

            // Tuyaux verticaux de connexion
            for (let i = -4; i <= 4; i += 2) {
                const pipe1 = new THREE.Mesh(pipeGeometry, pipeMaterial);
                pipe1.position.set(i, 2.896, -1.0);
                containerGroup.add(pipe1);

                const pipe2 = new THREE.Mesh(pipeGeometry, pipeMaterial);
                pipe2.position.set(i, 2.896, 1.0);
                containerGroup.add(pipe2);
            }

            // Tuyaux horizontaux sur le dry cooler
            const horizontalPipeGeometry = new THREE.CylinderGeometry(0.1, 0.1, 12.0, 16);
            const horizontalPipe1 = new THREE.Mesh(horizontalPipeGeometry, pipeMaterial);
            horizontalPipe1.rotation.z = Math.PI / 2;
            horizontalPipe1.position.set(0, 5.792, -1.0);
            containerGroup.add(horizontalPipe1);

            const horizontalPipe2 = new THREE.Mesh(horizontalPipeGeometry, pipeMaterial);
            horizontalPipe2.rotation.z = Math.PI / 2;
            horizontalPipe2.position.set(0, 5.792, 1.0);
            containerGroup.add(horizontalPipe2);
        }

        function createLogos(container) {
            // Logo Bitmain
            const logoGeometry = new THREE.PlaneGeometry(1.5, 0.6);
            const bitmainMaterial = new THREE.MeshStandardMaterial({
                color: COLORS.bitmainOrange,
                roughness: 0.3,
                metalness: 0.7,
                emissive: COLORS.bitmainOrange,
                emissiveIntensity: 0.3
            });
            const bitmainLogo = new THREE.Mesh(logoGeometry, bitmainMaterial);
            bitmainLogo.position.set(-6.15, 0.8, 0);
            bitmainLogo.rotation.y = Math.PI / 2;
            container.add(bitmainLogo);

            // Logo Hearst
            const hearstMaterial = new THREE.MeshStandardMaterial({
                color: COLORS.hearstGreen,
                roughness: 0.3,
                metalness: 0.7,
                emissive: COLORS.hearstGreen,
                emissiveIntensity: 0.3
            });
            const hearstLogo = new THREE.Mesh(logoGeometry, hearstMaterial);
            hearstLogo.position.set(-6.15, -0.3, 0);
            hearstLogo.rotation.y = Math.PI / 2;
            container.add(hearstLogo);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function resetCamera() {
            camera.position.set(30, 20, 30);
            camera.lookAt(0, 3, 0);
        }

        function toggleGrid() {
            gridHelper.visible = !gridHelper.visible;
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            scene.traverse((object) => {
                if (object.isMesh && object.material) {
                    object.material.wireframe = wireframeMode;
                }
            });
        }

        init();
    </script>
</body>
</html>







